"""
Practice doesn't make perfect. Practice makes myelin, and myelin makes perfect."
-Daniel Coyle

https://www.facebook.com/groups/selftaughtprogrammers

What is the single most effective thing you did to improve your programming skills?

##########

IMPLEMENTATION STEPS:

1) Pair programming with people far smarter than myself
(How do I get more experienced programmers to pair with me?)

2) Decide to be a jack-of-all-trades

3) Read about patterns and best practice.

4) Refactor until the code is elegant.

5) Read code written by different people. (open source is an opportunity)

6) Write documentation for code written by other people. (open source is an opportunity)

7) Exercise.

8) Create a project (see John Sonmez's "10 Steps to Learn Anything" course).

9) Teach someone else.

10) Learn one programming language every year. Start a project in that language. Release it as open source.

11) Learn to touch type.

12) Ask questions.

13) Learn Scheme.

14) Learn regular expressions.

##########

Working with people far smarter than myself

Always listening to what others have to say, regardless if they're junior, intermediate, senior or guru. job title doesn't mean anything.

Learning other frameworks/languages, and seeing how they do things, and compare that to stuff that I already know

Reading about patterns, best practices, and then examining my old stuff and applying those patterns where necessary

Pair programming

##########

Deciding TO be a 'Jack-of-all-Trades'

Fairly early in my career, I was an expert with a particular database and programming language. Unfortunately, that particular database lost the 'database wars', and I discovered that my career options were ... limited. After that I consciously decided that I would never let myself become boxed in like that again. So I studied everything I could get my hands on: Windows, Unix, C, C++, Java, C#, Perl, Python, Access, SQL Server, Oracle, Informix, MySQL, etc. Whatever tools and technologies are new or unusual, I became the 'go-to-guy' -- "Ask Craig, if he doesn't know it, he'll learn it."

##########

Most of the code I write will have to be maintained and extended for at least several years, so I should write the code with that in mind.

I should write automatic tests for my code.

I should never stop at the first working version, but refactor and refine until the code is elegant.

Never stop learning.

##########

Read code written by different people.

Write documentation for code written by other people.

##########

Hit the gym regularly.

Seriously, my brain works a whole lot better when I'm in shape. Problems become easier and less overwhelming, goofing off is much less of a temptation, and working through things step-by-step doesn't seem like such an arduous task.

##########

I always tell anyone who asks me how to program - just find a cool project (even if you have to make it up) and work on it.

You can learn all you want from books, podcasts and co-workers, but you have to apply it before you really understand it.

Code more, and code more different stuff. Because you don't learn much from repeating the same old trick.

##########

Took a part-time job tutoring CS students at my university. It really forces you to understand something at a completely different level when you have to explain it to someone else.

##########


I'm a big fan of the "learn one programming language every year" system. One year gives you enough time to get past the "okay, I know the syntax, so now I know the language" bias, and forces you to go a little farther and understand what's beneficial in that language, and program in a style native to that language (By which I mean, you don't end up writing java applications using Ruby syntax). Each language will change the way you think about programming- I knew how to use recursion, but thinking in recursion didn't happen until I took a class on prolog (I imagine a functional language like ML would have the same effect).

Start a Pet project. My personal equation for a good pet project is, something you have experience with + something you don't = app you would find useful. For instance, Migratr (my own caffeinated-weekend-turned-ongoing project) started out as "I know c#, but I've never coded against a web API. And I want to move all my photos to Zooomr". It could just as easily have been "I've coded against web API's before, but I don't know C#"

Publishing your pet project is an amazing educational experience in itself. Suddenly all the things practically nobody teaches but everybody's supposed to know (for me it was setting up your own testing system, getting the most out of version control systems, how to pace yourself when nobody else is setting your deadlines, how to interact with your users and how to know when to say "no" to feature requests), all that stuff bubbles to the surface and forces you to self-educate on a level you weren't before- at least not by idly reading flamewars on dzone about the pros/cons of the "foo" vs "bar" way of doing things.

Doing these two things covers both ends of the spectrum. Learning a new language will make you a better coder. The pet project will make you a better developer:P

##########

Learning assembly gives you insight into the way computers 'think' on a fundamentally lower level, and the elegance at this level is surprising... there are no wasted motions, no 'disposing' of data. Developing at this level will teach you efficiency and hone your critical thinking and logic skills. It will also cure you of any sloppy habits you have fairly quickly!

##########

There are books, there are coding katas, there are sites like this, but I believe that the best way to improve as a developer is to work on real project, with real fickle customers with real, ever-changing requirements with real engineering problems. There's no substitute for experience.

You can't really say you know what you're doing until you've written a non-trivial pile of code and stuck with it through a few product iterations with the business guys + the customers. You don't /really/ know how good your code is until it's time to make it change to meet new requirements.

##########

The basic things that helped me as a programmer:

    Learned Touch Typing.
    Learned to overcome shyness and ask questions.

##########

You can read all the books, code, and open source projects you like, but you need to understand the end-user aspect of software development. You need to step out of the echo chamber. So I'll address a couple non-technical points that will help your technical career.

    Step away from the keyboard and interact with the end-user and see, through their eyes, how they use the software. End users are typically not technical, so they see software as a magical piece of work, while you see software as a logical set of steps. The two worlds are completely different. So what seems easy and logical to you may seem cryptic and intimidating to others.

    Test, test, test. A lot of the software I've seen in large corporations use test cases. Hell, they use JUnit, xUnit, and all the other unit testing languages out there. But the problem I've seen is that most programmers never see what their software looks like in Production. Learn how users (or systems, if these are batch jobs) interact with your application, library, or interface to find out what kind of abhorrent information they throw at it. This will help you generate good test cases and stop assuming your program will always be fed the correct set of data.

    ##########


Learned Scheme.

##########

Learning regular expressions.

##########

Knowledge sharing sessions. Give a session or two to fellow team members for example. I believe teaching is one of the best ways to really learn the technology. I guarantee your level of understanding of the technology will become multi-fold, whether you audience gets it or not. :-)

##########

Hack on some open source project for a few months; the larger the better. When you're interacting with some highly opinionated, geographically diverse people who don't know you, you can't help but learn from your mistakes far faster - I think it's a certain embarassment factor. Plus, if you identify one or two really smart people, then you can glean valuable insight, if not pure knowledge, from them.

"""

